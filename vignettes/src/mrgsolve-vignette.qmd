---
title: "mrgsolve: Simulate from ODE-Based Models"
subtitle: "Get Started Package Vignette"
shorttitle: "Let's Get Started"
author: Kyle T. Baron
affiliation: Metrum Research Group
date: 2023-01-04
format: 
  pdf: 
    papersize: a4
    number-sections: true
    toc: true
    toc-title: Contents
    geometry: 
      - bottom=1.25in
      - left=1.25in
      - right=1.25in
      - top=1.25in
    include-in-header: 
      - header.tex

abstract: |
  \noindent mrgsolve is an R package maintained under the auspices of Metrum Research Group that facilitates simulation from models based on systems of ordinary differential equations (ODE) that are typically employed for understanding pharmacokinetics, pharmacodynamics, and systems biology and pharmacology. mrgsolve consists of computer code written in the R and C++ languages, providing an interface to a C++ translation of the lsoda differential equation solver. 
  \newline \newline
  \noindent This vignette will show you how to get started using mrgsolve. 
  \vskip 0.75cm \hrule
vignette: >
  %\VignetteIndexEntry{mrgsolve: Simulate from ODE-Based Models}
  %\VignetteKeyword{mrgsolve, r, ode}
  %\VignettePackage{mrgsolve}
---
\vskip 0.75cm
\hrule
\vskip 0.5cm

```{=latex}
\setlength{\parindent}{0pt}
```

This vignette introduces the mrgsolve workflow. First, load the package along 
with any other helper packages we need for this vignette.

```{r, message = FALSE, warning = FALSE}
library(mrgsolve)
library(dplyr)
```

# Get started

To get started with mrgsolve, try using the built in model library like this

```{r, message = FALSE}
mod <- modlib("pk1", delta = 0.1)

out <- mrgsim(mod, events = ev(amt = 100))

out
```

```{r, fig.margin = TRUE}
#| fig.cap: Simple simulation of a single dose
#| fig.height: 4
plot(out, "CP")
```

That was a really simple simulation where we used an event object to initiate
a dose into a one-compartment model. See how the `plot()` method allows us to 
quickly visualize what happend in the simulation. 

# Event objects

Event objects help you implement dosing events with a lightweight, easy to 
compose syntax. You construct them with the `ev()` function. So I can make an 
object for a single 100 mg bolus dose

```{r}
ev(amt = 100)
```

or we can code a series of intermittent infusions

```{r}
ev(amt = 100, rate = 50, ii = 24, addl = 3)
```

# Model Specification




In this chapter, we'll code up a very simple pharmacokinetic model. 
This is just starter material to get some concepts in place. We'll 
do more complicated stuff later (see @sec-specification-2).


![](pk-model.png)


Parameters

- `CL`
- `V`
- `KA`

Compartments

- `CENT`
- `DEPOT`

## Where to save your code?

- You can use any file name with any extension
- The extension you use may influence how your editor highlights and 
  indents your code
- I use `.mod`


## Model specification blocks

Model components are coded into blocks, which are delineated by a 
specific block syntax. You have a couple of options

__NONMEM style__

These start with `$` and then the block name (`$PK`)

__Bracket style__

Put the block name in brackets (`[ ERROR ]`)

__Upper or lower case__

You can use either:

- `$error`
- `[ pk ]`
- etc ... they all work


### Syntax

The "type" of code you write will vary from block to block. 
Sometimes it is an R-like syntax and sometimes it is 
`c++` code. 

Don't worry if you don't know `c++`! We have taken a lot of 
the complexity out and with a handful of exceptions, the 
code should be pretty natural and similar to what you write
in R. 

We will show you more `c++` in chapters to come.

## Base model blocks

### Parameters

Use the `$PARAM` block header.

```{r, eval = FALSE}
$PARAM 
CL = 1, V = 20, KA = 1.1
```

Parameters have a **name** and a **value**, separated by `=`.

Parameter names can be upper or lower case. If you want punctuation, 
use underscore `_`.

Parameter values must _evaluate_ to numeric.

Parameters can't be functions of other parameters _when writing the `$PARAM` block_. But there is a place where you can do this ...
we'll see this later on.

Multiple parameters can go on one line, but separate by comma.


### Read it in with `mread()`

Point `mread()` at your model file to

- read in the model
- see if it compiles

```{r}
mod <- mread("simple.mod")
```

We'll learn much more about `mread()` later on, but for now we need a way 
to check if our model coding is correct.


## Compartments

```{r, eval = FALSE}
$PARAM 
CL = 1, V = 20, KA = 1.1

$CMT DEPOT CENT
```

Compartments are named 

- Upper or lower case
- Punctuation use `_`

Order doesn't matter, except 

- When putting dosing records into the data set
- You want to use the NONMEM-style coding


## Differential equations

Now, we'll write ODE using `$DES` (or `$ODE`) block. 

```{r, eval = FALSE}
$PARAM 
CL = 1, V = 20, KA = 1.1

$CMT DEPOT CENT

$DES
dxdt_DEPOT = -KA * DEPOT;
dxdt_CENT  =  KA * DEPOT - (CL/V)*CENT;
```

Left hand side is `dxdt_<compartment name>`. 

Right hand side can reference

- Compartments
- Parameters
- Other quantities derived in `$DES` or `$PK`
- Other internal variables

Unlike `$PARAM` and `$CMT`, this is `c++` code

- Any valid `c++` code is allowed
- Each line (statement) should end in semi-colon `;`

## Derived outputs

Like NONMEM, derived can be calculated in the `$ERROR` block.

```{r, eval = FALSE}
$PARAM 
CL = 1, V = 20, KA = 1.1

$CMT DEPOT CENT

$DES
dxdt_DEPOT = -KA * DEPOT;
dxdt_CENT  =  KA * DEPOT - (CL/V)*CENT;

$ERROR
double CP = CENT/V;
```

Like `$DES`, this block must be valid `c++` code. 

Here we have created a new variable called `CP`, which is 
the amount in the central compartment divided by the 
central volume of distribution. 

When we create a new variable, we must declare its `type`. 
Use `double` for a floating point number. 

## Capture outputs into the simulated data

`mrgsolve` has a `$CAPTURE` block that works like 
NONMEM's `$TABLE`. Just list the names you want copied
into the output.

```{r, eval = FALSE}
$PARAM 
CL = 1, V = 20, KA = 1.1

$CMT DEPOT CENT

$DES
dxdt_DEPOT = -KA * DEPOT;
dxdt_CENT  =  KA * DEPOT - (CL/V)*CENT;

$ERROR
double CP = CENT/V;

$CAPTURE CP
```

Rather than putting stuff in `$CAPTURE`, try declaring with type `capture`

```{r, eval = FALSE}
$ERROR
capture CP = CENT/V;
```

`capture` is identical to type `double`, but tells `mrgsolve` to include this 
item in the simulated output.


A little-use feature is renaming items in `$CAPTURE`

```{r}
#| eval: false
$ERROR 
double DV = CENT/V;

$CAPTURE CP = DV
```
